/**
 * Sistema di Controllo Matrice LED 8x8 con Cursore
 * Utilizza 2 potenziometri per il movimento del cursore e un bottone per fissare/spegnere i LED
 * 
 * Hardware richiesto:
 * - Matrice LED 8x8 (strip WS2812B collegate in serpentine)
 * - 2 potenziometri (asse X e Y)
 * - 1 pulsante con pull-up
 * - Arduino Uno/Nano
 */

#include <Adafruit_NeoPixel.h>

// === CONFIGURAZIONE HARDWARE ===
#define PIN_MATRICE_LED    2    // Pin dati per la matrice LED
#define PIN_POTENZIOMETRO_X A0  // Potenziometro asse X
#define PIN_POTENZIOMETRO_Y A1  // Potenziometro asse Y  
#define PIN_BOTTONE        4    // Pulsante di controllo

// === CONFIGURAZIONE MATRICE ===
#define RIGHE              8
#define COLONNE            8
#define TOTALE_LED         (RIGHE * COLONNE)

// === CONFIGURAZIONE COLORI ===
#define COLORE_CURSORE     striscia.Color(255, 0, 0)     // Rosso per cursore
#define COLORE_LED_FISSO   striscia.Color(0, 255, 0)     // Verde per LED fissi
#define COLORE_SPENTO      striscia.Color(0, 0, 0)       // LED spento

// === CONFIGURAZIONE SISTEMA ===
#define SOGLIA_MOVIMENTO   5    // Soglia per ridurre jitter dei potenziometri
#define TEMPO_DEBOUNCE     50   // Tempo debounce bottone (ms)
#define REFRESH_RATE       20   // Velocità di aggiornamento (ms)

// === OGGETTI E VARIABILI GLOBALI ===
Adafruit_NeoPixel striscia(TOTALE_LED, PIN_MATRICE_LED, NEO_GRB + NEO_KHZ800);

// Stato del sistema
struct {
  uint8_t x, y;                    // Posizione corrente del cursore
  bool matrice_led[TOTALE_LED];    // Stato dei LED fissi (true = acceso)
  bool bottone_premuto;            // Flag per evitare pressioni multiple
  unsigned long ultimo_debounce;   // Timestamp per debounce
} sistema;

// === FUNZIONI DI UTILITÀ ===

/**
 * Converte coordinate (x,y) in indice lineare considerando il pattern serpentine
 * Le strip LED sono collegate in serie con pattern a zigzag:
 * Riga 0: 0->7, Riga 1: 15->8, Riga 2: 16->23, ecc.
 */
uint8_t coordinateAIndice(uint8_t x, uint8_t y) {
  if (y % 2 == 0) {
    // Righe pari: da sinistra a destra
    return y * COLONNE + x;
  } else {
    // Righe dispari: da destra a sinistra (serpentine)
    return y * COLONNE + (COLONNE - 1 - x);
  }
}

/**
 * Legge i potenziometri e aggiorna la posizione del cursore
 * Applica filtro anti-jitter per stabilizzare la lettura
 */
void aggiornaPosizionecursore() {
  static uint8_t x_precedente = 0, y_precedente = 0;
  
  // Lettura e mappatura potenziometri
  uint8_t nuova_x = map(analogRead(PIN_POTENZIOMETRO_X), 0, 1023, 0, COLONNE - 1);
  uint8_t nuova_y = map(analogRead(PIN_POTENZIOMETRO_Y), 0, 1023, 0, RIGHE - 1);
  
  // Filtro anti-jitter: aggiorna solo se il cambiamento è significativo
  if (abs(nuova_x - x_precedente) > 0 || abs(nuova_y - y_precedente) > 0) {
    sistema.x = nuova_x;
    sistema.y = nuova_y;
    x_precedente = nuova_x;
    y_precedente = nuova_y;
  }
}

/**
 * Gestisce la pressione del bottone con debounce
 * Toggle dello stato del LED nella posizione corrente del cursore
 */
void gestisciBottone() {
  bool stato_bottone = (digitalRead(PIN_BOTTONE) == LOW); // LOW = premuto (pull-up)
  unsigned long tempo_corrente = millis();
  
  // Debounce: ignora cambiamenti troppo rapidi
  if (tempo_corrente - sistema.ultimo_debounce < TEMPO_DEBOUNCE) {
    return;
  }
  
  // Rileva pressione (transizione da non premuto a premuto)
  if (stato_bottone && !sistema.bottone_premuto) {
    uint8_t indice = coordinateAIndice(sistema.x, sistema.y);
    
    // Toggle dello stato del LED
    sistema.matrice_led[indice] = !sistema.matrice_led[indice];
    
    sistema.ultimo_debounce = tempo_corrente;
  }
  
  sistema.bottone_premuto = stato_bottone;
}

/**
 * Aggiorna la visualizzazione della matrice LED
 * Priorità: 1) Cursore, 2) LED fissi, 3) LED spenti
 */
void aggiornaMatriceLED() {
  uint8_t indice_cursore = coordinateAIndice(sistema.x, sistema.y);
  
  for (uint8_t i = 0; i < TOTALE_LED; i++) {
    uint32_t colore;
    
    if (i == indice_cursore) {
      // Il cursore ha priorità massima
      colore = COLORE_CURSORE;
    } else if (sistema.matrice_led[i]) {
      // LED fissato dall'utente
      colore = COLORE_LED_FISSO;
    } else {
      // LED spento
      colore = COLORE_SPENTO;
    }
    
    striscia.setPixelColor(i, colore);
  }
  
  striscia.show();
}

/**
 * Inizializza il sistema
 */
void inizializzaSistema() {
  // Azzera stato del sistema
  sistema.x = 0;
  sistema.y = 0;
  sistema.bottone_premuto = false;
  sistema.ultimo_debounce = 0;
  
  // Inizializza array LED (tutti spenti)
  for (uint8_t i = 0; i < TOTALE_LED; i++) {
    sistema.matrice_led[i] = false;
  }
}

// === FUNZIONI PRINCIPALI ===

void setup() {
  // Inizializzazione comunicazione seriale per debug
  Serial.begin(9600);
  Serial.println("Inizializzazione Sistema Matrice LED 8x8");
  
  // Configurazione hardware
  pinMode(PIN_BOTTONE, INPUT_PULLUP);
  
  // Inizializzazione matrice LED
  striscia.begin();
  striscia.clear();
  striscia.show();
  
  // Inizializzazione sistema
  inizializzaSistema();
  
  Serial.println("Sistema pronto!");
}

void loop() {
  // Ciclo principale del sistema
  aggiornaPosizioneursore();
  gestisciBottone();
  aggiornaMatriceLED();
  
  // Controllo velocità di aggiornamento
  delay(REFRESH_RATE);
}

/**
 * CARATTERISTICHE DELLA VERSIONE MIGLIORATA:
 * 
 * 1. STRUTTURA MODULARE:
 *    - Funzioni specializzate per ogni compito
 *    - Codice più leggibile e manutenibile
 *    - Separazione logica delle responsabilità
 * 
 * 2. GESTIONE ERRORI:
 *    - Debounce per il bottone
 *    - Filtro anti-jitter per i potenziometri
 *    - Inizializzazione corretta di tutte le variabili
 * 
 * 3. CONFIGURABILITÀ:
 *    - Costanti definite per facili modifiche
 *    - Colori configurabili
 *    - Parametri di sistema modificabili
 * 
 * 4. EFFICIENZA:
 *    - Uso di uint8_t per ottimizzazione memoria
 *    - Struttura dati organizzata
 *    - Aggiornamenti solo quando necessario
 * 
 * 5. DOCUMENTAZIONE:
 *    - Commenti dettagliati
 *    - Spiegazione delle funzioni
 *    - Note sui pattern hardware
 * 
 * 6. ROBUSTEZZA:
 *    - Gestione corretta del pattern serpentine
 *    - Protezione da overflow
 *    - Controlli di validità
 */
